
#line 1 "p1-parser.rl"
/*
   File: p1-parser.rl

   	  Ragel state-machine definition and supporting functions
   	  to parse Dutch Smart Meter P1-telegrams (and a subset of generic IEC 62056-21 smart meter telegrams).
   	  
   	  (c)2017-2018, Levien van Zon (levien at zonnetjes.net, https://github.com/lvzon)
*/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <ctype.h>

#include <time.h>

#include "p1-parser.h"

#define ENABLE_DEBUG 1
#include "debug.h"


static long long int TST_to_time (dsmr_parser_t *fsm, int arg_idx) {
	
	// Get TST timestamp fields from stack and create a UNIX timestamp
	// The TST fields are: YYMMDDhhmmssX, with X = W for winter time or X = S for summer time
		
	struct tm tm;
	time_t time;
	
	tm.tm_year = fsm->arg[arg_idx] + 100;	// Years since 1900, our value was years since 2000
	tm.tm_mon = fsm->arg[arg_idx + 1] - 1;	// Months since start of year, starts at 0 (for January)
	tm.tm_mday = fsm->arg[arg_idx + 2];		// Ordinal day of the month
	tm.tm_hour = fsm->arg[arg_idx + 3];		// Hours past midnight, starts at 0
	tm.tm_min = fsm->arg[arg_idx + 4];		// Minutes past the hour
	tm.tm_sec = fsm->arg[arg_idx + 5];		// Seconds past the minute
	
	if (fsm->arg[arg_idx + 6] == 'S')		// Daylight saving time flag
		tm.tm_isdst = 1;						// Positive for daylight saving time (summer time)
	else if (fsm->arg[arg_idx + 6] == 'W')
		tm.tm_isdst = 0;						// Zero if DST is not in effect (winter time)
	else
		tm.tm_isdst = -1;						// Negative if DST information is not available
	
	DEBUG("Time: %d %d %d %d %d %d %d\n", tm.tm_year, tm.tm_mon, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec, tm.tm_isdst);
	
	if (!fsm->meter_timezone)
		fsm->meter_timezone = METER_TIMEZONE;
	
	const char *TZ = "TZ";
	char *oldval_TZ = getenv(TZ);
	setenv(TZ, fsm->meter_timezone, 1);		// Set TZ timezone environment variable to meter timezone
		
	time = mktime(&tm);
	
	if (oldval_TZ)
		setenv(TZ, oldval_TZ, 1);			// Restore TZ timezone environment variable
	
	return time;
}


/* Ragel state-machine definition */


#line 604 "p1-parser.rl"



#line 74 "p1-parser.c"
static const char _parser_actions[] = {
	0, 1, 0, 1, 1, 1, 2, 1, 
	3, 1, 7, 1, 8, 1, 9, 1, 
	10, 1, 11, 1, 12, 1, 13, 1, 
	61, 2, 0, 12, 2, 0, 13, 2, 
	4, 0, 2, 4, 12, 2, 6, 8, 
	2, 6, 9, 2, 6, 10, 2, 7, 
	14, 2, 15, 7, 2, 16, 7, 2, 
	17, 7, 2, 18, 7, 2, 19, 7, 
	2, 20, 7, 2, 21, 7, 2, 22, 
	7, 2, 23, 7, 2, 24, 7, 2, 
	25, 7, 2, 26, 7, 2, 27, 7, 
	2, 28, 7, 2, 29, 7, 2, 30, 
	7, 2, 31, 7, 2, 32, 7, 2, 
	33, 7, 2, 34, 7, 2, 35, 7, 
	2, 36, 7, 2, 37, 7, 2, 38, 
	7, 2, 39, 7, 2, 40, 7, 2, 
	43, 7, 2, 44, 7, 2, 45, 7, 
	2, 46, 7, 2, 47, 7, 2, 48, 
	7, 2, 49, 7, 2, 50, 7, 2, 
	51, 7, 2, 52, 7, 2, 53, 7, 
	2, 54, 7, 2, 60, 7, 3, 1, 
	42, 7, 3, 1, 56, 7, 3, 1, 
	57, 7, 3, 2, 6, 5, 3, 2, 
	6, 8, 3, 2, 41, 7, 3, 2, 
	55, 7, 3, 3, 58, 7, 3, 4, 
	0, 12, 3, 19, 59, 7
};

static const short _parser_key_offsets[] = {
	0, 0, 8, 9, 17, 24, 30, 33, 
	36, 37, 38, 39, 45, 46, 49, 50, 
	54, 55, 56, 57, 58, 60, 62, 64, 
	65, 66, 68, 71, 73, 74, 75, 76, 
	77, 79, 81, 83, 85, 87, 89, 91, 
	93, 95, 97, 99, 101, 103, 104, 105, 
	106, 107, 108, 109, 110, 111, 116, 119, 
	124, 125, 126, 127, 128, 129, 130, 131, 
	132, 133, 134, 136, 139, 140, 141, 142, 
	143, 146, 149, 150, 152, 158, 164, 171, 
	173, 176, 177, 179, 180, 187, 188, 189, 
	195, 202, 203, 204, 205, 212, 218, 225, 
	226, 227, 228, 229, 230, 232, 235, 236, 
	237, 238, 239, 240, 242, 243, 244, 246, 
	249, 250, 251, 252, 254, 257, 258, 259, 
	260, 262, 263, 264, 268, 269, 270, 271, 
	273, 276, 277, 278, 279, 280, 281, 283, 
	285, 287, 289, 291, 293, 295, 297, 299, 
	301, 303, 305, 307, 308, 309, 314, 317, 
	322, 323, 324, 325, 326, 327, 328, 329, 
	331, 333, 335, 337, 339, 341, 343, 345, 
	347, 349, 351, 353, 354, 355, 357, 360, 
	361, 363, 366, 367, 369, 372, 373, 374, 
	375, 377, 380, 381, 382, 383, 385, 386, 
	387, 388, 389, 390, 391, 392, 397, 400, 
	404, 406, 407, 408, 409, 410, 411, 412, 
	413, 414, 415, 417, 420, 421, 422, 423, 
	424, 425, 426, 427, 428, 434, 440, 447, 
	448, 449, 450, 452, 453, 462, 463, 465, 
	466, 467, 468, 473, 476, 481, 482, 483, 
	484, 485, 486, 488, 492, 497, 500, 505, 
	506, 507, 508, 509, 511, 514, 517, 519, 
	520, 521, 522, 527, 530, 535, 536, 537, 
	538, 539, 540, 542, 546, 551, 554, 559, 
	560, 561, 562, 563, 565, 568, 569, 570, 
	571, 572, 573, 578, 581, 586, 587, 588, 
	589, 590, 591, 592, 593, 594, 595, 600, 
	603, 608, 609, 610, 611, 612, 614, 615, 
	616, 617, 618, 619, 624, 627, 632, 633, 
	634, 635, 636, 637, 639, 641, 642, 643, 
	644, 646, 649, 650, 651, 652, 653, 654, 
	656, 659, 660, 661, 662, 663, 664, 669, 
	672, 677, 678, 679, 680, 681, 683, 684, 
	685, 686, 687, 688, 693, 696, 701, 702, 
	703, 704, 705, 706, 707, 708, 709, 710, 
	715, 718, 723, 724, 725, 726, 727, 729, 
	730, 731, 732, 733, 734, 739, 742, 747, 
	748, 749, 750, 751, 752, 754, 756, 757, 
	758, 759, 761, 764, 765, 766, 767, 768, 
	769, 771, 774, 775, 776, 777, 778, 779, 
	784, 787, 792, 793, 794, 795, 796, 798, 
	799, 800, 801, 802, 803, 808, 811, 816, 
	817, 818, 819, 820, 821, 822, 823, 824, 
	825, 830, 833, 838, 839, 840, 841, 842, 
	844, 845, 846, 847, 848, 849, 854, 857, 
	862, 863, 864, 865, 866, 867, 869, 871, 
	872, 873, 874, 876, 879, 880, 881, 882, 
	883, 884, 886, 889, 890, 891, 892, 893, 
	894, 899, 902, 907, 908, 909, 910, 911, 
	912, 913, 914, 915, 916, 917, 918, 920, 
	923, 925, 928, 931, 932, 933, 934, 935, 
	936, 937, 938, 939, 940, 941, 943, 945, 
	947, 949, 951, 953, 955, 957, 959, 961, 
	963, 965, 967, 969, 970, 971, 973, 977, 
	978, 979, 980, 981, 982, 983, 984, 985, 
	986, 993, 1001, 1002, 1003, 1010, 1016, 1017, 
	1018, 1019, 1020, 1021, 1022, 1023, 1025, 1026, 
	1027, 1028, 1029, 1031, 1039, 1047, 1055, 1056, 
	1057, 1058, 1059, 1060, 1061, 1062, 1063, 1065, 
	1067, 1069, 1071, 1073, 1075, 1077, 1079, 1081, 
	1083, 1085, 1087, 1089, 1090, 1091, 1096, 1099, 
	1104, 1105, 1106, 1107, 1108, 1111, 1113, 1120
};

static const char _parser_trans_keys[] = {
	13, 48, 49, 57, 65, 70, 97, 102, 
	10, 13, 120, 48, 57, 65, 70, 97, 
	102, 13, 48, 57, 65, 70, 97, 102, 
	48, 57, 65, 70, 97, 102, 10, 13, 
	94, 10, 13, 94, 10, 13, 10, 33, 
	48, 49, 55, 50, 57, 45, 48, 49, 
	52, 58, 48, 49, 50, 57, 46, 48, 
	46, 48, 40, 42, 33, 41, 33, 41, 
	13, 10, 48, 57, 40, 48, 57, 46, 
	55, 48, 46, 48, 40, 48, 57, 48, 
	57, 48, 57, 48, 57, 48, 57, 48, 
	57, 48, 57, 48, 57, 48, 57, 48, 
	57, 48, 57, 48, 57, 83, 87, 41, 
	13, 10, 46, 48, 46, 48, 40, 43, 
	45, 46, 48, 57, 46, 48, 57, 32, 
	42, 46, 48, 57, 41, 41, 13, 10, 
	52, 46, 52, 46, 48, 40, 48, 57, 
	41, 48, 57, 13, 10, 54, 46, 49, 
	51, 55, 46, 51, 52, 49, 40, 42, 
	48, 57, 65, 70, 97, 102, 48, 57, 
	65, 70, 97, 102, 41, 48, 57, 65, 
	70, 97, 102, 48, 57, 40, 48, 57, 
	46, 48, 49, 40, 41, 48, 57, 65, 
	70, 97, 102, 13, 10, 48, 57, 65, 
	70, 97, 102, 41, 48, 57, 65, 70, 
	97, 102, 13, 10, 40, 41, 48, 57, 
	65, 70, 97, 102, 48, 57, 65, 70, 
	97, 102, 41, 48, 57, 65, 70, 97, 
	102, 13, 10, 46, 48, 40, 48, 57, 
	41, 48, 57, 13, 10, 46, 49, 46, 
	50, 57, 49, 40, 48, 57, 41, 48, 
	57, 13, 10, 40, 48, 57, 41, 48, 
	57, 13, 10, 58, 50, 57, 52, 46, 
	49, 50, 51, 52, 46, 48, 40, 48, 
	57, 41, 48, 57, 13, 10, 46, 49, 
	40, 48, 57, 48, 57, 48, 57, 48, 
	57, 48, 57, 48, 57, 48, 57, 48, 
	57, 48, 57, 48, 57, 48, 57, 48, 
	57, 83, 87, 41, 40, 43, 45, 46, 
	48, 57, 46, 48, 57, 32, 42, 46, 
	48, 57, 41, 41, 13, 10, 46, 48, 
	40, 48, 57, 48, 57, 48, 57, 48, 
	57, 48, 57, 48, 57, 48, 57, 48, 
	57, 48, 57, 48, 57, 48, 57, 48, 
	57, 41, 40, 48, 57, 41, 48, 57, 
	40, 48, 57, 41, 48, 57, 40, 48, 
	57, 41, 48, 57, 40, 48, 45, 48, 
	57, 58, 48, 57, 50, 52, 46, 50, 
	51, 46, 49, 41, 40, 41, 41, 40, 
	43, 45, 46, 48, 57, 46, 48, 57, 
	41, 46, 48, 57, 13, 40, 46, 49, 
	41, 40, 41, 41, 46, 48, 40, 48, 
	57, 41, 48, 57, 13, 10, 54, 46, 
	49, 46, 48, 40, 48, 57, 65, 70, 
	97, 102, 48, 57, 65, 70, 97, 102, 
	41, 48, 57, 65, 70, 97, 102, 13, 
	10, 45, 48, 51, 58, 48, 49, 50, 
	51, 52, 53, 54, 55, 57, 46, 55, 
	56, 46, 48, 40, 43, 45, 46, 48, 
	57, 46, 48, 57, 32, 42, 46, 48, 
	57, 41, 41, 13, 10, 46, 48, 57, 
	40, 42, 48, 57, 43, 45, 46, 48, 
	57, 46, 48, 57, 32, 42, 46, 48, 
	57, 41, 41, 13, 10, 48, 57, 40, 
	48, 57, 46, 49, 50, 55, 56, 46, 
	48, 40, 43, 45, 46, 48, 57, 46, 
	48, 57, 32, 42, 46, 48, 57, 41, 
	41, 13, 10, 46, 48, 57, 40, 42, 
	48, 57, 43, 45, 46, 48, 57, 46, 
	48, 57, 32, 42, 46, 48, 57, 41, 
	41, 13, 10, 48, 57, 40, 48, 57, 
	46, 55, 46, 48, 40, 43, 45, 46, 
	48, 57, 46, 48, 57, 32, 42, 46, 
	48, 57, 41, 41, 13, 10, 46, 55, 
	46, 48, 40, 43, 45, 46, 48, 57, 
	46, 48, 57, 32, 42, 46, 48, 57, 
	41, 41, 13, 10, 49, 50, 46, 55, 
	46, 48, 40, 43, 45, 46, 48, 57, 
	46, 48, 57, 32, 42, 46, 48, 57, 
	41, 41, 13, 10, 46, 51, 55, 50, 
	54, 46, 48, 40, 48, 57, 41, 48, 
	57, 13, 10, 46, 48, 40, 48, 57, 
	41, 48, 57, 13, 10, 46, 48, 40, 
	43, 45, 46, 48, 57, 46, 48, 57, 
	32, 42, 46, 48, 57, 41, 41, 13, 
	10, 49, 50, 46, 55, 46, 48, 40, 
	43, 45, 46, 48, 57, 46, 48, 57, 
	32, 42, 46, 48, 57, 41, 41, 13, 
	10, 46, 55, 46, 48, 40, 43, 45, 
	46, 48, 57, 46, 48, 57, 32, 42, 
	46, 48, 57, 41, 41, 13, 10, 49, 
	50, 46, 55, 46, 48, 40, 43, 45, 
	46, 48, 57, 46, 48, 57, 32, 42, 
	46, 48, 57, 41, 41, 13, 10, 46, 
	51, 55, 50, 54, 46, 48, 40, 48, 
	57, 41, 48, 57, 13, 10, 46, 48, 
	40, 48, 57, 41, 48, 57, 13, 10, 
	46, 48, 40, 43, 45, 46, 48, 57, 
	46, 48, 57, 32, 42, 46, 48, 57, 
	41, 41, 13, 10, 49, 50, 46, 55, 
	46, 48, 40, 43, 45, 46, 48, 57, 
	46, 48, 57, 32, 42, 46, 48, 57, 
	41, 41, 13, 10, 46, 55, 46, 48, 
	40, 43, 45, 46, 48, 57, 46, 48, 
	57, 32, 42, 46, 48, 57, 41, 41, 
	13, 10, 49, 50, 46, 55, 46, 48, 
	40, 43, 45, 46, 48, 57, 46, 48, 
	57, 32, 42, 46, 48, 57, 41, 41, 
	13, 10, 46, 51, 55, 50, 54, 46, 
	48, 40, 48, 57, 41, 48, 57, 13, 
	10, 46, 48, 40, 48, 57, 41, 48, 
	57, 13, 10, 46, 48, 40, 43, 45, 
	46, 48, 57, 46, 48, 57, 32, 42, 
	46, 48, 57, 41, 41, 13, 10, 57, 
	46, 57, 55, 46, 48, 40, 48, 57, 
	41, 48, 57, 13, 40, 48, 49, 57, 
	45, 48, 57, 48, 58, 57, 54, 46, 
	55, 46, 49, 57, 41, 13, 40, 48, 
	57, 48, 57, 48, 57, 48, 57, 48, 
	57, 48, 57, 48, 57, 48, 57, 48, 
	57, 48, 57, 48, 57, 48, 57, 83, 
	87, 41, 40, 48, 57, 32, 42, 48, 
	57, 41, 41, 58, 48, 46, 50, 46, 
	56, 40, 48, 49, 57, 65, 70, 97, 
	102, 41, 120, 48, 57, 65, 70, 97, 
	102, 13, 10, 41, 48, 57, 65, 70, 
	97, 102, 48, 57, 65, 70, 97, 102, 
	45, 48, 58, 48, 45, 48, 58, 48, 
	50, 46, 48, 46, 48, 40, 42, 33, 
	41, 48, 57, 65, 70, 97, 102, 33, 
	41, 48, 57, 65, 70, 97, 102, 33, 
	41, 48, 57, 65, 70, 97, 102, 13, 
	10, 51, 46, 49, 46, 48, 40, 48, 
	57, 48, 57, 48, 57, 48, 57, 48, 
	57, 48, 57, 48, 57, 48, 57, 48, 
	57, 48, 57, 48, 57, 48, 57, 83, 
	87, 41, 40, 43, 45, 46, 48, 57, 
	46, 48, 57, 32, 42, 46, 48, 57, 
	41, 41, 13, 10, 10, 13, 94, 10, 
	13, 33, 47, 48, 49, 55, 50, 57, 
	0
};

static const char _parser_single_lengths[] = {
	0, 2, 1, 2, 1, 0, 3, 3, 
	1, 1, 1, 4, 1, 1, 1, 4, 
	1, 1, 1, 1, 2, 2, 2, 1, 
	1, 0, 1, 2, 1, 1, 1, 1, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 2, 1, 1, 1, 
	1, 1, 1, 1, 1, 3, 1, 3, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 0, 1, 1, 1, 1, 1, 
	3, 3, 1, 2, 0, 0, 1, 0, 
	1, 1, 2, 1, 1, 1, 1, 0, 
	1, 1, 1, 1, 1, 0, 1, 1, 
	1, 1, 1, 1, 0, 1, 1, 1, 
	1, 1, 1, 2, 1, 1, 0, 1, 
	1, 1, 1, 0, 1, 1, 1, 1, 
	2, 1, 1, 4, 1, 1, 1, 0, 
	1, 1, 1, 1, 1, 1, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 2, 1, 1, 3, 1, 3, 
	1, 1, 1, 1, 1, 1, 1, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 1, 1, 0, 1, 1, 
	0, 1, 1, 0, 1, 1, 1, 1, 
	0, 1, 1, 1, 1, 2, 1, 1, 
	1, 1, 1, 1, 1, 3, 1, 2, 
	2, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 0, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 0, 0, 1, 1, 
	1, 1, 2, 1, 9, 1, 2, 1, 
	1, 1, 3, 1, 3, 1, 1, 1, 
	1, 1, 0, 2, 3, 1, 3, 1, 
	1, 1, 1, 0, 1, 3, 2, 1, 
	1, 1, 3, 1, 3, 1, 1, 1, 
	1, 1, 0, 2, 3, 1, 3, 1, 
	1, 1, 1, 0, 1, 1, 1, 1, 
	1, 1, 3, 1, 3, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 3, 1, 
	3, 1, 1, 1, 1, 2, 1, 1, 
	1, 1, 1, 3, 1, 3, 1, 1, 
	1, 1, 1, 2, 2, 1, 1, 1, 
	0, 1, 1, 1, 1, 1, 1, 0, 
	1, 1, 1, 1, 1, 1, 3, 1, 
	3, 1, 1, 1, 1, 2, 1, 1, 
	1, 1, 1, 3, 1, 3, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 3, 
	1, 3, 1, 1, 1, 1, 2, 1, 
	1, 1, 1, 1, 3, 1, 3, 1, 
	1, 1, 1, 1, 2, 2, 1, 1, 
	1, 0, 1, 1, 1, 1, 1, 1, 
	0, 1, 1, 1, 1, 1, 1, 3, 
	1, 3, 1, 1, 1, 1, 2, 1, 
	1, 1, 1, 1, 3, 1, 3, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	3, 1, 3, 1, 1, 1, 1, 2, 
	1, 1, 1, 1, 1, 3, 1, 3, 
	1, 1, 1, 1, 1, 2, 2, 1, 
	1, 1, 0, 1, 1, 1, 1, 1, 
	1, 0, 1, 1, 1, 1, 1, 1, 
	3, 1, 3, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 0, 1, 
	2, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 2, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 2, 1, 1, 0, 2, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 2, 1, 1, 1, 0, 1, 1, 
	1, 1, 1, 1, 1, 2, 1, 1, 
	1, 1, 2, 2, 2, 2, 1, 1, 
	1, 1, 1, 1, 1, 1, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 2, 1, 1, 3, 1, 3, 
	1, 1, 1, 1, 3, 2, 5, 0
};

static const char _parser_range_lengths[] = {
	0, 3, 0, 3, 3, 3, 0, 0, 
	0, 0, 0, 1, 0, 1, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 1, 1, 0, 0, 0, 0, 0, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 1, 1, 1, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 1, 1, 0, 0, 0, 0, 
	0, 0, 0, 0, 3, 3, 3, 1, 
	1, 0, 0, 0, 3, 0, 0, 3, 
	3, 0, 0, 0, 3, 3, 3, 0, 
	0, 0, 0, 0, 1, 1, 0, 0, 
	0, 0, 0, 0, 0, 0, 1, 1, 
	0, 0, 0, 1, 1, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 1, 
	1, 0, 0, 0, 0, 0, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 0, 0, 0, 1, 1, 1, 
	0, 0, 0, 0, 0, 0, 0, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 0, 0, 1, 1, 0, 
	1, 1, 0, 1, 1, 0, 0, 0, 
	1, 1, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 1, 1, 1, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 1, 1, 0, 0, 0, 0, 
	0, 0, 0, 0, 3, 3, 3, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 1, 1, 1, 0, 0, 0, 
	0, 0, 1, 1, 1, 1, 1, 0, 
	0, 0, 0, 1, 1, 0, 0, 0, 
	0, 0, 1, 1, 1, 0, 0, 0, 
	0, 0, 1, 1, 1, 1, 1, 0, 
	0, 0, 0, 1, 1, 0, 0, 0, 
	0, 0, 1, 1, 1, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 1, 1, 
	1, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 1, 1, 1, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	1, 1, 0, 0, 0, 0, 0, 1, 
	1, 0, 0, 0, 0, 0, 1, 1, 
	1, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 1, 1, 1, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 1, 
	1, 1, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 1, 1, 1, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 1, 1, 0, 0, 0, 0, 0, 
	1, 1, 0, 0, 0, 0, 0, 1, 
	1, 1, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 1, 1, 1, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	1, 1, 1, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 1, 1, 1, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 1, 1, 0, 0, 0, 0, 
	0, 1, 1, 0, 0, 0, 0, 0, 
	1, 1, 1, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 1, 1, 
	0, 1, 1, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 0, 0, 0, 1, 1, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	3, 3, 0, 0, 3, 3, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 3, 3, 3, 0, 0, 
	0, 0, 0, 0, 0, 0, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 0, 0, 0, 1, 1, 1, 
	0, 0, 0, 0, 0, 0, 1, 0
};

static const short _parser_index_offsets[] = {
	0, 0, 6, 8, 14, 19, 23, 27, 
	31, 33, 35, 37, 43, 45, 48, 50, 
	55, 57, 59, 61, 63, 66, 69, 72, 
	74, 76, 78, 81, 84, 86, 88, 90, 
	92, 94, 96, 98, 100, 102, 104, 106, 
	108, 110, 112, 114, 116, 119, 121, 123, 
	125, 127, 129, 131, 133, 135, 140, 143, 
	148, 150, 152, 154, 156, 158, 160, 162, 
	164, 166, 168, 170, 173, 175, 177, 179, 
	181, 185, 189, 191, 194, 198, 202, 207, 
	209, 212, 214, 217, 219, 224, 226, 228, 
	232, 237, 239, 241, 243, 248, 252, 257, 
	259, 261, 263, 265, 267, 269, 272, 274, 
	276, 278, 280, 282, 285, 287, 289, 291, 
	294, 296, 298, 300, 302, 305, 307, 309, 
	311, 314, 316, 318, 323, 325, 327, 329, 
	331, 334, 336, 338, 340, 342, 344, 346, 
	348, 350, 352, 354, 356, 358, 360, 362, 
	364, 366, 368, 371, 373, 375, 380, 383, 
	388, 390, 392, 394, 396, 398, 400, 402, 
	404, 406, 408, 410, 412, 414, 416, 418, 
	420, 422, 424, 426, 428, 430, 432, 435, 
	437, 439, 442, 444, 446, 449, 451, 453, 
	455, 457, 460, 462, 464, 466, 469, 471, 
	473, 475, 477, 479, 481, 483, 488, 491, 
	495, 498, 500, 502, 504, 506, 508, 510, 
	512, 514, 516, 518, 521, 523, 525, 527, 
	529, 531, 533, 535, 537, 541, 545, 550, 
	552, 554, 556, 559, 561, 571, 573, 576, 
	578, 580, 582, 587, 590, 595, 597, 599, 
	601, 603, 605, 607, 611, 616, 619, 624, 
	626, 628, 630, 632, 634, 637, 641, 644, 
	646, 648, 650, 655, 658, 663, 665, 667, 
	669, 671, 673, 675, 679, 684, 687, 692, 
	694, 696, 698, 700, 702, 705, 707, 709, 
	711, 713, 715, 720, 723, 728, 730, 732, 
	734, 736, 738, 740, 742, 744, 746, 751, 
	754, 759, 761, 763, 765, 767, 770, 772, 
	774, 776, 778, 780, 785, 788, 793, 795, 
	797, 799, 801, 803, 806, 809, 811, 813, 
	815, 817, 820, 822, 824, 826, 828, 830, 
	832, 835, 837, 839, 841, 843, 845, 850, 
	853, 858, 860, 862, 864, 866, 869, 871, 
	873, 875, 877, 879, 884, 887, 892, 894, 
	896, 898, 900, 902, 904, 906, 908, 910, 
	915, 918, 923, 925, 927, 929, 931, 934, 
	936, 938, 940, 942, 944, 949, 952, 957, 
	959, 961, 963, 965, 967, 970, 973, 975, 
	977, 979, 981, 984, 986, 988, 990, 992, 
	994, 996, 999, 1001, 1003, 1005, 1007, 1009, 
	1014, 1017, 1022, 1024, 1026, 1028, 1030, 1033, 
	1035, 1037, 1039, 1041, 1043, 1048, 1051, 1056, 
	1058, 1060, 1062, 1064, 1066, 1068, 1070, 1072, 
	1074, 1079, 1082, 1087, 1089, 1091, 1093, 1095, 
	1098, 1100, 1102, 1104, 1106, 1108, 1113, 1116, 
	1121, 1123, 1125, 1127, 1129, 1131, 1134, 1137, 
	1139, 1141, 1143, 1145, 1148, 1150, 1152, 1154, 
	1156, 1158, 1160, 1163, 1165, 1167, 1169, 1171, 
	1173, 1178, 1181, 1186, 1188, 1190, 1192, 1194, 
	1196, 1198, 1200, 1202, 1204, 1206, 1208, 1210, 
	1213, 1216, 1219, 1222, 1224, 1226, 1228, 1230, 
	1232, 1234, 1236, 1238, 1240, 1242, 1245, 1247, 
	1249, 1251, 1253, 1255, 1257, 1259, 1261, 1263, 
	1265, 1267, 1269, 1272, 1274, 1276, 1278, 1282, 
	1284, 1286, 1288, 1290, 1292, 1294, 1296, 1298, 
	1300, 1305, 1311, 1313, 1315, 1320, 1324, 1326, 
	1328, 1330, 1332, 1334, 1336, 1338, 1341, 1343, 
	1345, 1347, 1349, 1352, 1358, 1364, 1370, 1372, 
	1374, 1376, 1378, 1380, 1382, 1384, 1386, 1388, 
	1390, 1392, 1394, 1396, 1398, 1400, 1402, 1404, 
	1406, 1408, 1410, 1413, 1415, 1417, 1422, 1425, 
	1430, 1432, 1434, 1436, 1438, 1442, 1445, 1452
};

static const short _parser_trans_targs[] = {
	2, 3, 4, 4, 4, 0, 574, 0, 
	2, 5, 4, 4, 4, 0, 2, 4, 
	4, 4, 0, 4, 4, 4, 0, 0, 
	0, 0, 7, 0, 8, 0, 7, 9, 
	0, 10, 0, 11, 0, 1, 12, 225, 
	530, 526, 0, 13, 0, 14, 119, 0, 
	15, 0, 16, 27, 60, 70, 0, 17, 
	0, 18, 0, 19, 0, 20, 0, 21, 
	25, 0, 0, 0, 22, 0, 23, 22, 
	24, 0, 11, 0, 26, 0, 21, 26, 
	0, 28, 48, 0, 29, 0, 30, 0, 
	31, 0, 32, 0, 33, 0, 34, 0, 
	35, 0, 36, 0, 37, 0, 38, 0, 
	39, 0, 40, 0, 41, 0, 42, 0, 
	43, 0, 44, 0, 45, 45, 0, 46, 
	0, 47, 0, 11, 0, 49, 0, 50, 
	0, 51, 0, 52, 0, 53, 0, 54, 
	54, 55, 55, 0, 55, 55, 0, 56, 
	56, 55, 55, 0, 0, 57, 58, 57, 
	59, 0, 11, 0, 61, 0, 62, 0, 
	63, 0, 64, 0, 65, 0, 66, 0, 
	67, 0, 68, 67, 0, 69, 0, 11, 
	0, 71, 0, 72, 0, 73, 104, 106, 
	0, 74, 81, 97, 0, 75, 0, 76, 
	79, 0, 77, 77, 77, 0, 78, 78, 
	78, 0, 23, 77, 77, 77, 0, 80, 
	0, 76, 80, 0, 82, 0, 83, 91, 
	0, 84, 0, 85, 87, 87, 87, 0, 
	86, 0, 11, 0, 88, 88, 88, 0, 
	89, 87, 87, 87, 0, 90, 0, 11, 
	0, 92, 0, 85, 93, 93, 93, 0, 
	94, 94, 94, 0, 95, 93, 93, 93, 
	0, 96, 0, 11, 0, 98, 0, 99, 
	0, 100, 0, 101, 0, 102, 101, 0, 
	103, 0, 11, 0, 105, 0, 64, 0, 
	107, 0, 108, 114, 0, 109, 0, 110, 
	0, 111, 0, 112, 111, 0, 113, 0, 
	11, 0, 115, 0, 116, 0, 117, 116, 
	0, 118, 0, 11, 0, 120, 0, 121, 
	214, 0, 122, 0, 123, 0, 124, 131, 
	156, 207, 0, 125, 0, 126, 0, 127, 
	0, 128, 0, 129, 128, 0, 130, 0, 
	11, 0, 132, 0, 133, 0, 134, 0, 
	135, 0, 136, 0, 137, 0, 138, 0, 
	139, 0, 140, 0, 141, 0, 142, 0, 
	143, 0, 144, 0, 145, 0, 146, 0, 
	147, 147, 0, 148, 0, 149, 0, 150, 
	150, 151, 151, 0, 151, 151, 0, 152, 
	152, 151, 151, 0, 0, 153, 154, 153, 
	155, 0, 11, 0, 157, 0, 158, 0, 
	159, 0, 160, 0, 161, 0, 162, 0, 
	163, 0, 164, 0, 165, 0, 166, 0, 
	167, 0, 168, 0, 169, 0, 170, 0, 
	171, 0, 172, 0, 173, 0, 174, 0, 
	175, 174, 0, 176, 0, 177, 0, 178, 
	177, 0, 179, 0, 180, 0, 181, 180, 
	0, 182, 0, 183, 0, 184, 0, 185, 
	0, 186, 185, 0, 187, 0, 188, 0, 
	189, 0, 190, 201, 0, 191, 0, 192, 
	0, 193, 0, 194, 0, 0, 195, 196, 
	195, 197, 0, 198, 198, 199, 199, 0, 
	199, 199, 0, 200, 199, 199, 0, 86, 
	197, 0, 202, 0, 203, 0, 204, 0, 
	205, 0, 0, 206, 196, 206, 208, 0, 
	209, 0, 210, 0, 211, 0, 212, 211, 
	0, 213, 0, 11, 0, 215, 0, 216, 
	0, 217, 0, 218, 0, 219, 0, 220, 
	0, 221, 221, 221, 0, 222, 222, 222, 
	0, 223, 221, 221, 221, 0, 224, 0, 
	11, 0, 226, 0, 227, 513, 0, 228, 
	0, 16, 229, 253, 301, 341, 366, 406, 
	431, 471, 0, 230, 0, 231, 241, 0, 
	232, 0, 233, 0, 234, 0, 235, 235, 
	236, 236, 0, 236, 236, 0, 237, 237, 
	236, 236, 0, 0, 238, 239, 238, 240, 
	0, 11, 0, 242, 0, 243, 0, 244, 
	251, 243, 0, 245, 245, 246, 246, 0, 
	246, 246, 0, 247, 247, 246, 246, 0, 
	0, 248, 249, 248, 250, 0, 11, 0, 
	252, 0, 244, 252, 0, 254, 277, 289, 
	0, 255, 265, 0, 256, 0, 257, 0, 
	258, 0, 259, 259, 260, 260, 0, 260, 
	260, 0, 261, 261, 260, 260, 0, 0, 
	262, 263, 262, 264, 0, 11, 0, 266, 
	0, 267, 0, 268, 275, 267, 0, 269, 
	269, 270, 270, 0, 270, 270, 0, 271, 
	271, 270, 270, 0, 0, 272, 273, 272, 
	274, 0, 11, 0, 276, 0, 268, 276, 
	0, 278, 0, 279, 0, 280, 0, 281, 
	0, 282, 0, 283, 283, 284, 284, 0, 
	284, 284, 0, 285, 285, 284, 284, 0, 
	0, 286, 287, 286, 288, 0, 11, 0, 
	290, 0, 291, 0, 292, 0, 293, 0, 
	294, 0, 295, 295, 296, 296, 0, 296, 
	296, 0, 297, 297, 296, 296, 0, 0, 
	298, 299, 298, 300, 0, 11, 0, 302, 
	314, 0, 303, 0, 304, 0, 305, 0, 
	306, 0, 307, 0, 308, 308, 309, 309, 
	0, 309, 309, 0, 310, 310, 309, 309, 
	0, 0, 311, 312, 311, 313, 0, 11, 
	0, 315, 0, 316, 331, 0, 317, 324, 
	0, 318, 0, 319, 0, 320, 0, 321, 
	0, 322, 321, 0, 323, 0, 11, 0, 
	325, 0, 326, 0, 327, 0, 328, 0, 
	329, 328, 0, 330, 0, 11, 0, 332, 
	0, 333, 0, 334, 0, 335, 335, 336, 
	336, 0, 336, 336, 0, 337, 337, 336, 
	336, 0, 0, 338, 339, 338, 340, 0, 
	11, 0, 342, 354, 0, 343, 0, 344, 
	0, 345, 0, 346, 0, 347, 0, 348, 
	348, 349, 349, 0, 349, 349, 0, 350, 
	350, 349, 349, 0, 0, 351, 352, 351, 
	353, 0, 11, 0, 355, 0, 356, 0, 
	357, 0, 358, 0, 359, 0, 360, 360, 
	361, 361, 0, 361, 361, 0, 362, 362, 
	361, 361, 0, 0, 363, 364, 363, 365, 
	0, 11, 0, 367, 379, 0, 368, 0, 
	369, 0, 370, 0, 371, 0, 372, 0, 
	373, 373, 374, 374, 0, 374, 374, 0, 
	375, 375, 374, 374, 0, 0, 376, 377, 
	376, 378, 0, 11, 0, 380, 0, 381, 
	396, 0, 382, 389, 0, 383, 0, 384, 
	0, 385, 0, 386, 0, 387, 386, 0, 
	388, 0, 11, 0, 390, 0, 391, 0, 
	392, 0, 393, 0, 394, 393, 0, 395, 
	0, 11, 0, 397, 0, 398, 0, 399, 
	0, 400, 400, 401, 401, 0, 401, 401, 
	0, 402, 402, 401, 401, 0, 0, 403, 
	404, 403, 405, 0, 11, 0, 407, 419, 
	0, 408, 0, 409, 0, 410, 0, 411, 
	0, 412, 0, 413, 413, 414, 414, 0, 
	414, 414, 0, 415, 415, 414, 414, 0, 
	0, 416, 417, 416, 418, 0, 11, 0, 
	420, 0, 421, 0, 422, 0, 423, 0, 
	424, 0, 425, 425, 426, 426, 0, 426, 
	426, 0, 427, 427, 426, 426, 0, 0, 
	428, 429, 428, 430, 0, 11, 0, 432, 
	444, 0, 433, 0, 434, 0, 435, 0, 
	436, 0, 437, 0, 438, 438, 439, 439, 
	0, 439, 439, 0, 440, 440, 439, 439, 
	0, 0, 441, 442, 441, 443, 0, 11, 
	0, 445, 0, 446, 461, 0, 447, 454, 
	0, 448, 0, 449, 0, 450, 0, 451, 
	0, 452, 451, 0, 453, 0, 11, 0, 
	455, 0, 456, 0, 457, 0, 458, 0, 
	459, 458, 0, 460, 0, 11, 0, 462, 
	0, 463, 0, 464, 0, 465, 465, 466, 
	466, 0, 466, 466, 0, 467, 467, 466, 
	466, 0, 0, 468, 469, 468, 470, 0, 
	11, 0, 472, 0, 473, 0, 474, 0, 
	475, 0, 476, 0, 477, 0, 478, 0, 
	479, 0, 480, 479, 0, 86, 481, 0, 
	482, 495, 0, 483, 496, 0, 484, 0, 
	485, 0, 486, 0, 487, 0, 488, 0, 
	489, 0, 490, 0, 491, 0, 492, 0, 
	493, 0, 86, 494, 0, 495, 0, 496, 
	0, 497, 0, 498, 0, 499, 0, 500, 
	0, 501, 0, 502, 0, 503, 0, 504, 
	0, 505, 0, 506, 0, 507, 507, 0, 
	508, 0, 509, 0, 510, 0, 511, 511, 
	510, 0, 0, 512, 493, 512, 514, 0, 
	515, 0, 516, 0, 517, 0, 518, 0, 
	519, 0, 520, 0, 521, 524, 524, 524, 
	0, 522, 525, 524, 524, 524, 0, 523, 
	0, 11, 0, 522, 524, 524, 524, 0, 
	524, 524, 524, 0, 527, 0, 528, 0, 
	529, 0, 16, 0, 531, 0, 532, 0, 
	533, 0, 534, 544, 0, 535, 0, 536, 
	0, 537, 0, 538, 0, 539, 25, 0, 
	0, 0, 540, 540, 540, 22, 0, 23, 
	541, 541, 541, 22, 0, 542, 540, 540, 
	540, 22, 543, 0, 11, 0, 545, 0, 
	546, 0, 547, 0, 548, 0, 549, 0, 
	550, 0, 551, 0, 552, 0, 553, 0, 
	554, 0, 555, 0, 556, 0, 557, 0, 
	558, 0, 559, 0, 560, 0, 561, 0, 
	562, 0, 563, 563, 0, 564, 0, 565, 
	0, 566, 566, 567, 567, 0, 567, 567, 
	0, 568, 568, 567, 567, 0, 0, 569, 
	570, 569, 571, 0, 11, 0, 573, 573, 
	0, 572, 575, 575, 0, 1, 6, 12, 
	225, 530, 526, 0, 0, 0
};

static const unsigned char _parser_trans_actions[] = {
	0, 43, 43, 43, 43, 23, 52, 23, 
	5, 0, 15, 15, 15, 23, 5, 15, 
	15, 15, 23, 43, 43, 43, 23, 23, 
	23, 23, 31, 23, 3, 23, 1, 0, 
	23, 0, 23, 49, 23, 0, 0, 0, 
	0, 0, 23, 0, 23, 0, 37, 23, 
	0, 23, 0, 0, 0, 0, 23, 0, 
	23, 0, 23, 0, 23, 0, 23, 0, 
	0, 23, 23, 23, 31, 23, 3, 1, 
	0, 23, 61, 23, 0, 23, 0, 0, 
	23, 0, 0, 23, 0, 23, 0, 23, 
	0, 23, 0, 23, 37, 23, 11, 23, 
	182, 23, 11, 23, 182, 23, 11, 23, 
	182, 23, 11, 23, 182, 23, 11, 23, 
	182, 23, 11, 23, 178, 178, 23, 0, 
	23, 0, 23, 58, 23, 0, 23, 0, 
	23, 0, 23, 0, 23, 0, 23, 0, 
	17, 40, 40, 23, 40, 40, 23, 7, 
	7, 13, 13, 23, 23, 31, 3, 1, 
	0, 23, 82, 23, 0, 23, 0, 23, 
	0, 23, 0, 23, 0, 23, 0, 23, 
	37, 23, 5, 11, 23, 0, 23, 67, 
	23, 0, 23, 0, 23, 0, 0, 0, 
	23, 0, 0, 0, 23, 0, 23, 0, 
	0, 23, 34, 34, 34, 23, 21, 21, 
	21, 23, 3, 19, 19, 19, 23, 0, 
	23, 0, 0, 23, 0, 23, 0, 0, 
	23, 0, 23, 0, 34, 34, 34, 23, 
	0, 23, 9, 23, 21, 21, 21, 23, 
	3, 19, 19, 19, 23, 0, 23, 148, 
	23, 0, 23, 0, 34, 34, 34, 23, 
	21, 21, 21, 23, 3, 19, 19, 19, 
	23, 0, 23, 145, 23, 0, 23, 0, 
	23, 0, 23, 37, 23, 5, 11, 23, 
	0, 23, 64, 23, 0, 23, 0, 23, 
	0, 23, 0, 0, 23, 0, 23, 0, 
	23, 37, 23, 5, 11, 23, 0, 23, 
	121, 23, 0, 23, 37, 23, 5, 11, 
	23, 0, 23, 124, 23, 5, 23, 0, 
	0, 23, 0, 23, 0, 23, 0, 0, 
	0, 0, 23, 0, 23, 0, 23, 0, 
	23, 37, 23, 5, 11, 23, 0, 23, 
	151, 23, 0, 23, 0, 23, 0, 23, 
	37, 23, 11, 23, 182, 23, 11, 23, 
	182, 23, 11, 23, 182, 23, 11, 23, 
	182, 23, 11, 23, 182, 23, 11, 23, 
	178, 178, 23, 0, 23, 0, 23, 0, 
	17, 40, 40, 23, 40, 40, 23, 7, 
	7, 13, 13, 23, 23, 31, 3, 1, 
	0, 23, 160, 23, 0, 23, 0, 23, 
	0, 23, 37, 23, 11, 23, 182, 23, 
	11, 23, 182, 23, 11, 23, 182, 23, 
	11, 23, 182, 23, 11, 23, 182, 23, 
	11, 23, 5, 23, 0, 23, 37, 23, 
	5, 11, 23, 0, 23, 37, 23, 5, 
	11, 23, 0, 23, 37, 23, 190, 11, 
	23, 0, 23, 0, 23, 0, 23, 0, 
	23, 0, 0, 23, 0, 23, 0, 23, 
	0, 23, 0, 0, 23, 0, 23, 0, 
	23, 0, 23, 0, 23, 23, 31, 170, 
	1, 0, 23, 0, 17, 40, 40, 23, 
	40, 40, 23, 194, 13, 13, 23, 0, 
	0, 23, 0, 23, 0, 23, 0, 23, 
	0, 23, 23, 31, 174, 1, 0, 23, 
	0, 23, 0, 23, 37, 23, 5, 11, 
	23, 0, 23, 157, 23, 0, 23, 0, 
	23, 0, 23, 0, 23, 0, 23, 0, 
	23, 34, 34, 34, 23, 21, 21, 21, 
	23, 3, 19, 19, 19, 23, 0, 23, 
	154, 23, 0, 23, 0, 0, 23, 0, 
	23, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 23, 0, 23, 0, 0, 23, 
	0, 23, 0, 23, 0, 23, 0, 17, 
	40, 40, 23, 40, 40, 23, 7, 7, 
	13, 13, 23, 23, 31, 3, 1, 0, 
	23, 76, 23, 0, 23, 37, 23, 5, 
	5, 11, 23, 0, 17, 40, 40, 23, 
	40, 40, 23, 7, 7, 13, 13, 23, 
	23, 31, 3, 1, 0, 23, 70, 23, 
	0, 23, 0, 0, 23, 0, 0, 0, 
	23, 0, 0, 23, 0, 23, 0, 23, 
	0, 23, 0, 17, 40, 40, 23, 40, 
	40, 23, 7, 7, 13, 13, 23, 23, 
	31, 3, 1, 0, 23, 79, 23, 0, 
	23, 37, 23, 5, 5, 11, 23, 0, 
	17, 40, 40, 23, 40, 40, 23, 7, 
	7, 13, 13, 23, 23, 31, 3, 1, 
	0, 23, 73, 23, 0, 23, 0, 0, 
	23, 0, 23, 0, 23, 0, 23, 0, 
	23, 0, 23, 0, 17, 40, 40, 23, 
	40, 40, 23, 7, 7, 13, 13, 23, 
	23, 31, 3, 1, 0, 23, 103, 23, 
	0, 23, 0, 23, 0, 23, 0, 23, 
	0, 23, 0, 17, 40, 40, 23, 40, 
	40, 23, 7, 7, 13, 13, 23, 23, 
	31, 3, 1, 0, 23, 112, 23, 0, 
	0, 23, 0, 23, 0, 23, 0, 23, 
	0, 23, 0, 23, 0, 17, 40, 40, 
	23, 40, 40, 23, 7, 7, 13, 13, 
	23, 23, 31, 3, 1, 0, 23, 85, 
	23, 0, 23, 0, 0, 23, 0, 0, 
	23, 0, 23, 0, 23, 0, 23, 37, 
	23, 5, 11, 23, 0, 23, 127, 23, 
	0, 23, 0, 23, 0, 23, 37, 23, 
	5, 11, 23, 0, 23, 136, 23, 0, 
	23, 0, 23, 0, 23, 0, 17, 40, 
	40, 23, 40, 40, 23, 7, 7, 13, 
	13, 23, 23, 31, 3, 1, 0, 23, 
	94, 23, 0, 0, 23, 0, 23, 0, 
	23, 0, 23, 0, 23, 0, 23, 0, 
	17, 40, 40, 23, 40, 40, 23, 7, 
	7, 13, 13, 23, 23, 31, 3, 1, 
	0, 23, 106, 23, 0, 23, 0, 23, 
	0, 23, 0, 23, 0, 23, 0, 17, 
	40, 40, 23, 40, 40, 23, 7, 7, 
	13, 13, 23, 23, 31, 3, 1, 0, 
	23, 115, 23, 0, 0, 23, 0, 23, 
	0, 23, 0, 23, 0, 23, 0, 23, 
	0, 17, 40, 40, 23, 40, 40, 23, 
	7, 7, 13, 13, 23, 23, 31, 3, 
	1, 0, 23, 88, 23, 0, 23, 0, 
	0, 23, 0, 0, 23, 0, 23, 0, 
	23, 0, 23, 37, 23, 5, 11, 23, 
	0, 23, 130, 23, 0, 23, 0, 23, 
	0, 23, 37, 23, 5, 11, 23, 0, 
	23, 139, 23, 0, 23, 0, 23, 0, 
	23, 0, 17, 40, 40, 23, 40, 40, 
	23, 7, 7, 13, 13, 23, 23, 31, 
	3, 1, 0, 23, 97, 23, 0, 0, 
	23, 0, 23, 0, 23, 0, 23, 0, 
	23, 0, 23, 0, 17, 40, 40, 23, 
	40, 40, 23, 7, 7, 13, 13, 23, 
	23, 31, 3, 1, 0, 23, 109, 23, 
	0, 23, 0, 23, 0, 23, 0, 23, 
	0, 23, 0, 17, 40, 40, 23, 40, 
	40, 23, 7, 7, 13, 13, 23, 23, 
	31, 3, 1, 0, 23, 118, 23, 0, 
	0, 23, 0, 23, 0, 23, 0, 23, 
	0, 23, 0, 23, 0, 17, 40, 40, 
	23, 40, 40, 23, 7, 7, 13, 13, 
	23, 23, 31, 3, 1, 0, 23, 91, 
	23, 0, 23, 0, 0, 23, 0, 0, 
	23, 0, 23, 0, 23, 0, 23, 37, 
	23, 5, 11, 23, 0, 23, 133, 23, 
	0, 23, 0, 23, 0, 23, 37, 23, 
	5, 11, 23, 0, 23, 142, 23, 0, 
	23, 0, 23, 0, 23, 0, 17, 40, 
	40, 23, 40, 40, 23, 7, 7, 13, 
	13, 23, 23, 31, 3, 1, 0, 23, 
	100, 23, 0, 23, 0, 23, 0, 23, 
	0, 23, 0, 23, 0, 23, 0, 23, 
	37, 23, 186, 11, 23, 0, 0, 23, 
	37, 37, 23, 0, 11, 23, 0, 23, 
	0, 23, 0, 23, 0, 23, 0, 23, 
	0, 23, 0, 23, 0, 23, 0, 23, 
	0, 23, 0, 0, 23, 37, 23, 11, 
	23, 182, 23, 11, 23, 182, 23, 11, 
	23, 182, 23, 11, 23, 182, 23, 11, 
	23, 182, 23, 11, 23, 178, 178, 23, 
	0, 23, 0, 23, 37, 23, 5, 5, 
	11, 23, 23, 31, 166, 1, 0, 23, 
	0, 23, 0, 23, 0, 23, 0, 23, 
	0, 23, 0, 23, 43, 43, 43, 43, 
	23, 5, 0, 15, 15, 15, 23, 0, 
	23, 55, 23, 5, 15, 15, 15, 23, 
	43, 43, 43, 23, 0, 23, 0, 23, 
	0, 23, 0, 23, 0, 23, 0, 23, 
	0, 23, 0, 0, 23, 0, 23, 0, 
	23, 0, 23, 0, 23, 0, 0, 23, 
	23, 23, 198, 198, 198, 31, 23, 3, 
	28, 28, 28, 1, 23, 3, 25, 25, 
	25, 1, 0, 23, 202, 23, 0, 23, 
	0, 23, 0, 23, 0, 23, 0, 23, 
	0, 23, 37, 23, 11, 23, 182, 23, 
	11, 23, 182, 23, 11, 23, 182, 23, 
	11, 23, 182, 23, 11, 23, 182, 23, 
	11, 23, 178, 178, 23, 0, 23, 0, 
	23, 0, 17, 40, 40, 23, 40, 40, 
	23, 7, 7, 13, 13, 23, 23, 31, 
	3, 1, 0, 23, 163, 23, 0, 0, 
	0, 0, 46, 46, 0, 0, 0, 0, 
	0, 0, 0, 23, 0, 0
};

static const unsigned char _parser_eof_actions[] = {
	0, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 23, 0, 0, 0, 0
};

static const int parser_start = 574;
static const int parser_first_final = 574;
static const int parser_error = 0;

static const int parser_en_rest_of_line = 572;
static const int parser_en_main = 574;


#line 607 "p1-parser.rl"


void dsmr_parser_init(dsmr_parser_t *fsm )
{
	int arg;
	
	fsm->buflen = 0;
	fsm->argc = 0;
	for (arg = 0 ; arg < PARSER_MAXARGS ; arg++)
		fsm->arg[arg] = 0;
	fsm->multiplier = 1;
	fsm->bitcount = 0;
	fsm->strargc = 0;
	for (arg = 0 ; arg < PARSER_MAXARGS ; arg++)
		fsm->strarg[arg] = NULL;
	fsm->parse_errors = 0;
	fsm->meter_timezone = NULL;
	
	
#line 1021 "p1-parser.c"
	{
	 fsm->cs = parser_start;
	}

#line 626 "p1-parser.rl"
}

void dsmr_parser_execute(dsmr_parser_t *fsm, const char *data, int len, int eofflag)
{
	const char *p = data;
	const char *pe = data + len;
	const char *eof = 0;

	if (eofflag)
		eof = pe;
	
	
#line 1039 "p1-parser.c"
	{
	int _klen;
	unsigned int _trans;
	const char *_acts;
	unsigned int _nacts;
	const char *_keys;

	if ( p == pe )
		goto _test_eof;
	if (  fsm->cs == 0 )
		goto _out;
_resume:
	_keys = _parser_trans_keys + _parser_key_offsets[ fsm->cs];
	_trans = _parser_index_offsets[ fsm->cs];

	_klen = _parser_single_lengths[ fsm->cs];
	if ( _klen > 0 ) {
		const char *_lower = _keys;
		const char *_mid;
		const char *_upper = _keys + _klen - 1;
		while (1) {
			if ( _upper < _lower )
				break;

			_mid = _lower + ((_upper-_lower) >> 1);
			if ( (*p) < *_mid )
				_upper = _mid - 1;
			else if ( (*p) > *_mid )
				_lower = _mid + 1;
			else {
				_trans += (unsigned int)(_mid - _keys);
				goto _match;
			}
		}
		_keys += _klen;
		_trans += _klen;
	}

	_klen = _parser_range_lengths[ fsm->cs];
	if ( _klen > 0 ) {
		const char *_lower = _keys;
		const char *_mid;
		const char *_upper = _keys + (_klen<<1) - 2;
		while (1) {
			if ( _upper < _lower )
				break;

			_mid = _lower + (((_upper-_lower) >> 1) & ~1);
			if ( (*p) < _mid[0] )
				_upper = _mid - 2;
			else if ( (*p) > _mid[1] )
				_lower = _mid + 2;
			else {
				_trans += (unsigned int)((_mid - _keys)>>1);
				goto _match;
			}
		}
		_trans += _klen;
	}

_match:
	 fsm->cs = _parser_trans_targs[_trans];

	if ( _parser_trans_actions[_trans] == 0 )
		goto _again;

	_acts = _parser_actions + _parser_trans_actions[_trans];
	_nacts = (unsigned int) *_acts++;
	while ( _nacts-- > 0 )
	{
		switch ( *_acts++ )
		{
	case 0:
#line 16 "parser-tools.rl"
	{
		if ( fsm->buflen < PARSER_BUFLEN )
			fsm->buffer[fsm->buflen++] = (*p);
	}
	break;
	case 1:
#line 22 "parser-tools.rl"
	{
		if ( fsm->buflen < PARSER_BUFLEN )
			fsm->buffer[fsm->buflen++] = 0;
	}
	break;
	case 2:
#line 32 "parser-tools.rl"
	{ 
		fsm->arg[fsm->argc] *= fsm->multiplier;
		if ( fsm->argc < PARSER_MAXARGS )
			fsm->argc++;
		fsm->multiplier = 1;
	}
	break;
	case 3:
#line 40 "parser-tools.rl"
	{ 
		
		// Add integer value
		fsm->arg[fsm->argc] *= fsm->multiplier;
		if ( fsm->argc < PARSER_MAXARGS )
			fsm->argc++;
		fsm->multiplier = 1;
		
		// Add divider, calculated as 10^decimalpos, the decimal position from the end
		//printf("Decimal position: %d\n", fsm->decimalpos);
		if (fsm->decimalpos >= 0 && fsm->decimalpos <= MAX_DIVIDER_EXP)
			fsm->arg[fsm->argc] = pow10[fsm->decimalpos];
		else if (fsm->decimalpos == -1)
			fsm->arg[fsm->argc] = 1;
		else
			fsm->arg[fsm->argc] = 0;
		
		if ( fsm->argc < PARSER_MAXARGS )
			fsm->argc++;
		fsm->decimalpos = -1;
	}
	break;
	case 4:
#line 63 "parser-tools.rl"
	{
		if ( fsm->strargc < PARSER_MAXARGS )
			fsm->strarg[fsm->strargc++] = fsm->buffer + fsm->buflen;
	}
	break;
	case 5:
#line 69 "parser-tools.rl"
	{ 
		fsm->arg[fsm->argc] = (*p);
		if ( fsm->argc < PARSER_MAXARGS )
			fsm->argc++;
	}
	break;
	case 6:
#line 76 "parser-tools.rl"
	{ 
		fsm->arg[fsm->argc] = 0;
		fsm->bitcount = 0;
		fsm->decimalpos = -1;
	}
	break;
	case 7:
#line 83 "parser-tools.rl"
	{
		int arg;
		for (arg = 0 ; arg < fsm->argc ; arg++) {
			// printf("clearing argument %d of %d\n", arg, fsm->argc);
			fsm->arg[arg] = 0;
		}
		fsm->multiplier = 1;
		fsm->argc = 0;
		fsm->bitcount = 0;
		fsm->decimalpos = -1;
		
		for (arg = 0 ; arg < fsm->strargc ; arg++) {
			fsm->strarg[arg] = NULL;
		}
		fsm->strargc = 0;
		fsm->buflen = 0;
	}
	break;
	case 8:
#line 122 "parser-tools.rl"
	{ 
		fsm->arg[fsm->argc] = fsm->arg[fsm->argc] * 10 + ((*p) - '0');
	}
	break;
	case 9:
#line 128 "parser-tools.rl"
	{ 
	
		if ((*p) == '.') {
				fsm->decimalpos = 0;
		} else {
		
			fsm->arg[fsm->argc] = fsm->arg[fsm->argc] * 10 + ((*p) - '0');
			
			if (fsm->decimalpos >= 0) {
				// Everytime we see a digit after the decimal point, increase counter
				fsm->decimalpos += 1;
			}

		}
	}
	break;
	case 10:
#line 145 "parser-tools.rl"
	{ 
		
		int value;
		
		if (isdigit((*p))) {
			value = (*p) - '0';
		} else if (isupper((*p))) {
			value = (*p) - 'A' + 10;
		} else {
			value = (*p) - 'a' + 10;
		}
		
		fsm->arg[fsm->argc] = fsm->arg[fsm->argc] * 16 + value;
	}
	break;
	case 11:
#line 161 "parser-tools.rl"
	{ 
		fsm->multiplier = -1;
	}
	break;
	case 12:
#line 182 "parser-tools.rl"
	{
		
		unsigned int value;
		
		if (isdigit((*p))) {
			value = (*p) - '0';
		} else if (isupper((*p))) {
			value = (*p) - 'A' + 10;
		} else {
			value = (*p) - 'a' + 10;
		}
		
		unsigned char byte = value << 4; 
		unsigned char *dest;
		
		if ( fsm->buflen < PARSER_BUFLEN ) {
			dest = (unsigned char *)(fsm->buffer) + fsm->buflen;
			*dest = byte; 
		}		
	}
	break;
	case 13:
#line 204 "parser-tools.rl"
	{
		
		unsigned int value;
		
		if (isdigit((*p))) {
			value = (*p) - '0';
		} else if (isupper((*p))) {
			value = (*p) - 'A' + 10;
		} else {
			value = (*p) - 'a' + 10;
		}
		
		unsigned char nibble = value & 0x0f;
		unsigned char *dest;
		
		if ( fsm->buflen < PARSER_BUFLEN ) {
			dest = (unsigned char *)(fsm->buffer) + fsm->buflen++;
			*dest = (*dest & 0xf0) | nibble;
		}		
	}
	break;
	case 14:
#line 72 "p1-parser.rl"
	{ { fsm->cs = 574;goto _again;} }
	break;
	case 15:
#line 76 "p1-parser.rl"
	{ 
		DEBUG("Header: %s\n", fsm->strarg[0]); 
		strncpy((char *)(fsm->data->header), fsm->strarg[0], LEN_HEADER); 
	}
	break;
	case 16:
#line 81 "p1-parser.rl"
	{ 
		if (fsm->arg[0]) {
			DEBUG("CRC: 0x%x\n", (unsigned int)fsm->arg[0]); 
		}
		fsm->crc16 = fsm->arg[0]; 
	}
	break;
	case 17:
#line 88 "p1-parser.rl"
	{ 
		fsm->data->P1_version_major = fsm->arg[0] >> 4;
		fsm->data->P1_version_minor = fsm->arg[0] & 0xf;
		DEBUG("P1 version: %d.%d\n", (int)(fsm->data->P1_version_major), (int)(fsm->data->P1_version_minor)); 
	}
	break;
	case 18:
#line 94 "p1-parser.rl"
	{
		fsm->data->timestamp = TST_to_time(fsm, 0);
		DEBUG("Timestamp: %lu\n", (unsigned long)(fsm->data->timestamp));
	}
	break;
	case 19:
#line 99 "p1-parser.rl"
	{ 
		DEBUG("Equipment ID: %s\n", fsm->strarg[0]);
		strncpy((char *)(fsm->data->equipment_id), fsm->strarg[0], LEN_EQUIPMENT_ID); 
	}
	break;
	case 20:
#line 104 "p1-parser.rl"
	{ 
		fsm->data->tariff = fsm->arg[0];
		DEBUG("Tariff: %u\n", (unsigned int)(fsm->data->tariff));
	}
	break;
	case 21:
#line 109 "p1-parser.rl"
	{ 
		fsm->data->switchpos = fsm->arg[0];
		DEBUG("Switch position: %d\n", (int)(fsm->data->switchpos));
	}
	break;
	case 22:
#line 114 "p1-parser.rl"
	{
		unsigned int tariff = fsm->arg[0];
		double value = (double)fsm->arg[1] / (double)fsm->arg[2];
		if (tariff > MAX_TARIFFS) {
			DEBUG("Tariff %u out of range, max. %u, E_in %f %s\n", tariff, MAX_TARIFFS, value, fsm->strarg[0]);
		} else {
			fsm->data->E_in[tariff] = value;
			strncpy((char *)(fsm->data->unit_E_in[tariff]), fsm->strarg[0], LEN_UNIT + 1);
			DEBUG("Energy in, tariff %u: %f %s\n", tariff, value, fsm->strarg[0]); 
		}
	}
	break;
	case 23:
#line 126 "p1-parser.rl"
	{
		unsigned int tariff = fsm->arg[0];
		double value = (double)fsm->arg[1] / (double)fsm->arg[2];
		if (tariff > MAX_TARIFFS) {
			DEBUG("Tariff %u out of range, max. %u, E_out %f %s\n", tariff, MAX_TARIFFS, value, fsm->strarg[0]);
		} else {
			fsm->data->E_out[tariff] = value;
			strncpy((char *)(fsm->data->unit_E_out[tariff]), fsm->strarg[0], LEN_UNIT + 1);
			DEBUG("Energy out, tariff %u: %f %s\n", tariff, value, fsm->strarg[0]); 
		}
	}
	break;
	case 24:
#line 144 "p1-parser.rl"
	{ 
		fsm->data->P_in_total = (double)fsm->arg[0] / (double)fsm->arg[1];
		strncpy((char *)(fsm->data->unit_P_in_total), fsm->strarg[0], LEN_UNIT + 1);
		DEBUG("Power in: %f %s\n", fsm->data->P_in_total, fsm->strarg[0]); 
	}
	break;
	case 25:
#line 150 "p1-parser.rl"
	{ 
		fsm->data->P_out_total = (double)fsm->arg[0] / (double)fsm->arg[1];
		strncpy((char *)(fsm->data->unit_P_out_total), fsm->strarg[0], LEN_UNIT + 1);
		DEBUG("Power out: %f %s\n", fsm->data->P_out_total, fsm->strarg[0]); 
	}
	break;
	case 26:
#line 156 "p1-parser.rl"
	{ 
		fsm->data->P_threshold = (double)fsm->arg[0] / (double)fsm->arg[1];
		strncpy((char *)(fsm->data->unit_P_threshold), fsm->strarg[0], LEN_UNIT + 1);
		DEBUG("Power threshold: %f %s\n", fsm->data->P_threshold, fsm->strarg[0]); 
	}
	break;
	case 27:
#line 162 "p1-parser.rl"
	{ 
		if (MAX_PHASES >= 1) {
			fsm->data->I[0] = (double)fsm->arg[0] / (double)fsm->arg[1];
			strncpy((char *)(fsm->data->unit_I[0]), fsm->strarg[0], LEN_UNIT + 1);
			DEBUG("Current L1: %f %s\n", fsm->data->I[0], fsm->strarg[0]); 
		}
	}
	break;
	case 28:
#line 170 "p1-parser.rl"
	{ 
		if (MAX_PHASES >= 2) {
			fsm->data->I[1] = (double)fsm->arg[0] / (double)fsm->arg[1];
			strncpy((char *)(fsm->data->unit_I[1]), fsm->strarg[0], LEN_UNIT + 1);
			DEBUG("Current L2: %f %s\n", fsm->data->I[1], fsm->strarg[0]); 
		}
	}
	break;
	case 29:
#line 178 "p1-parser.rl"
	{ 
		if (MAX_PHASES >= 3) {
			fsm->data->I[2] = (double)fsm->arg[0] / (double)fsm->arg[1];
			strncpy((char *)(fsm->data->unit_I[2]), fsm->strarg[0], LEN_UNIT + 1);
			DEBUG("Current L3: %f %s\n", fsm->data->I[2], fsm->strarg[0]); 
		}
	}
	break;
	case 30:
#line 186 "p1-parser.rl"
	{ 
		if (MAX_PHASES >= 1) {
			fsm->data->V[0] = (double)fsm->arg[0] / (double)fsm->arg[1];
			strncpy((char *)(fsm->data->unit_V[0]), fsm->strarg[0], LEN_UNIT + 1);
			DEBUG("Voltage L1: %f %s\n", fsm->data->V[0], fsm->strarg[0]); 
		}
	}
	break;
	case 31:
#line 194 "p1-parser.rl"
	{ 
		if (MAX_PHASES >= 2) {
			fsm->data->V[1] = (double)fsm->arg[0] / (double)fsm->arg[1];
			strncpy((char *)(fsm->data->unit_V[1]), fsm->strarg[0], LEN_UNIT + 1);
			DEBUG("Voltage L2: %f %s\n", fsm->data->V[1], fsm->strarg[0]); 
		}
	}
	break;
	case 32:
#line 202 "p1-parser.rl"
	{ 
		if (MAX_PHASES >= 3) {
			fsm->data->V[2] = (double)fsm->arg[0] / (double)fsm->arg[1];
			strncpy((char *)(fsm->data->unit_V[2]), fsm->strarg[0], LEN_UNIT + 1);
			DEBUG("Voltage L3: %f %s\n", fsm->data->V[2], fsm->strarg[0]); 
		}
	}
	break;
	case 33:
#line 210 "p1-parser.rl"
	{ 
		if (MAX_PHASES >= 1) {
			fsm->data->P_in[0] = (double)fsm->arg[0] / (double)fsm->arg[1];
			strncpy((char *)(fsm->data->unit_P_in[0]), fsm->strarg[0], LEN_UNIT + 1);
			DEBUG("Power in L1: %f %s\n", fsm->data->P_in[0], fsm->strarg[0]);
		}
	}
	break;
	case 34:
#line 218 "p1-parser.rl"
	{ 
		if (MAX_PHASES >= 2) {
			fsm->data->P_in[1] = (double)fsm->arg[0] / (double)fsm->arg[1];
			strncpy((char *)(fsm->data->unit_P_in[1]), fsm->strarg[0], LEN_UNIT + 1);
			DEBUG("Power in L2: %f %s\n", fsm->data->P_in[1], fsm->strarg[0]);
		}
	}
	break;
	case 35:
#line 226 "p1-parser.rl"
	{ 
		if (MAX_PHASES >= 3) {
			fsm->data->P_in[2] = (double)fsm->arg[0] / (double)fsm->arg[1];
			strncpy((char *)(fsm->data->unit_P_in[2]), fsm->strarg[0], LEN_UNIT + 1);
			DEBUG("Power in L3: %f %s\n", fsm->data->P_in[2], fsm->strarg[0]);
		}
	}
	break;
	case 36:
#line 234 "p1-parser.rl"
	{ 
		if (MAX_PHASES >= 1) {
			fsm->data->P_out[0] = (double)fsm->arg[0] / (double)fsm->arg[1];
			strncpy((char *)(fsm->data->unit_P_out[0]), fsm->strarg[0], LEN_UNIT + 1);
			DEBUG("Power out L1: %f %s\n", fsm->data->P_out[0], fsm->strarg[0]);
		}
	}
	break;
	case 37:
#line 242 "p1-parser.rl"
	{ 
		if (MAX_PHASES >= 2) {
			fsm->data->P_out[1] = (double)fsm->arg[0] / (double)fsm->arg[1];
			strncpy((char *)(fsm->data->unit_P_out[1]), fsm->strarg[0], LEN_UNIT + 1);
			DEBUG("Power out L2: %f %s\n", fsm->data->P_out[1], fsm->strarg[0]);
		}
	}
	break;
	case 38:
#line 250 "p1-parser.rl"
	{ 
		if (MAX_PHASES >= 3) {
			fsm->data->P_out[2] = (double)fsm->arg[0] / (double)fsm->arg[1];
			strncpy((char *)(fsm->data->unit_P_out[2]), fsm->strarg[0], LEN_UNIT + 1);
			DEBUG("Power out L3: %f %s\n", fsm->data->P_out[2], fsm->strarg[0]);
		}
	}
	break;
	case 39:
#line 258 "p1-parser.rl"
	{ 
		fsm->data->power_failures = fsm->arg[0];
		DEBUG("Power failures: %lu\n", (unsigned long)(fsm->data->power_failures));
	}
	break;
	case 40:
#line 263 "p1-parser.rl"
	{ 
		fsm->data->power_failures_long = fsm->arg[0];
		DEBUG("Long power failures: %lu\n", (unsigned long)(fsm->data->power_failures_long));
	}
	break;
	case 41:
#line 268 "p1-parser.rl"
	{ 
		fsm->data->pfail_events = fsm->arg[0];
		fsm->pfaileventcount = 0;
		DEBUG("Power failure events: %u\n", (unsigned int)(fsm->data->pfail_events));
	}
	break;
	case 42:
#line 274 "p1-parser.rl"
	{
		uint32_t timestamp = TST_to_time(fsm, 0);
		uint32_t duration = fsm->arg[7];
		DEBUG("Power failure event end time %lu, %lu %s\n", (unsigned long)timestamp, (unsigned long)duration, fsm->strarg[0]);
		if (fsm->pfaileventcount < MAX_EVENTS) {
			fsm->data->pfail_event_end_time[fsm->pfaileventcount] = timestamp;
			fsm->data->pfail_event_duration[fsm->pfaileventcount] = duration;
			strncpy((char *)(fsm->data->unit_pfail_event_duration[fsm->pfaileventcount]), fsm->strarg[0], LEN_UNIT + 1);
		} else {
			DEBUG("Power failure event overflow, count %d, max %d\n", fsm->pfaileventcount, MAX_EVENTS);
		}
		fsm->pfaileventcount++;
	}
	break;
	case 43:
#line 288 "p1-parser.rl"
	{ 
		if (MAX_PHASES >= 1) {
			fsm->data->V_sags[0] = fsm->arg[0];
			DEBUG("Voltage sags L1: %lu\n", (unsigned long)(fsm->data->V_sags[0]));
		}
	}
	break;
	case 44:
#line 295 "p1-parser.rl"
	{ 
		if (MAX_PHASES >= 2) {
			fsm->data->V_sags[1] = fsm->arg[0];
			DEBUG("Voltage sags L2: %lu\n", (unsigned long)(fsm->data->V_sags[1]));
		}
	}
	break;
	case 45:
#line 302 "p1-parser.rl"
	{ 
		if (MAX_PHASES >= 3) {
			fsm->data->V_sags[2] = fsm->arg[0];
			DEBUG("Voltage sags L3: %lu\n", (unsigned long)(fsm->data->V_sags[2]));
		}
	}
	break;
	case 46:
#line 309 "p1-parser.rl"
	{ 
		if (MAX_PHASES >= 1) {
			fsm->data->V_swells[0] = fsm->arg[0];
			DEBUG("Voltage swells L1: %lu\n", (unsigned long)(fsm->data->V_swells[0]));
		}
	}
	break;
	case 47:
#line 316 "p1-parser.rl"
	{ 
		if (MAX_PHASES >= 2) {
			fsm->data->V_swells[1] = fsm->arg[0];
			DEBUG("Voltage swells L2: %lu\n", (unsigned long)(fsm->data->V_swells[1]));
		}
	}
	break;
	case 48:
#line 323 "p1-parser.rl"
	{ 
		if (MAX_PHASES >= 3) {
			fsm->data->V_swells[2] = fsm->arg[0];
			DEBUG("Voltage swells L3: %lu\n", (unsigned long)(fsm->data->V_swells[2]));
		}
	}
	break;
	case 49:
#line 330 "p1-parser.rl"
	{ 
		DEBUG("Text message codes: %s\n", fsm->strarg[0]);
		strncpy((char *)(fsm->data->textmsg_codes), fsm->strarg[0], LEN_MESSAGE_CODES + 1);
	}
	break;
	case 50:
#line 335 "p1-parser.rl"
	{ 
		DEBUG("Text message: %s\n", fsm->strarg[0]);
		strncpy((char *)(fsm->data->textmsg), fsm->strarg[0], LEN_MESSAGE + 1);
	}
	break;
	case 51:
#line 340 "p1-parser.rl"
	{ 
		unsigned int dev = fsm->arg[0] - 1;
		unsigned int type = fsm->arg[1];
		if (dev < MAX_DEVS) {
			DEBUG("Device %u type: %u\n", dev + 1, type);
			fsm->data->dev_type[dev] = type;
		} else {
			DEBUG("Device ID %u out of range, max %u, type %u\n", dev + 1, MAX_DEVS, type);
		}
	}
	break;
	case 52:
#line 351 "p1-parser.rl"
	{ 
		unsigned int dev = fsm->arg[0] - 1;
		if (dev < MAX_DEVS) {
			DEBUG("Device %u ID: %s\n", dev + 1, fsm->strarg[0]);
			strncpy((char *)(fsm->data->dev_id[dev]), fsm->strarg[0], LEN_EQUIPMENT_ID);
		} else {
			DEBUG("Device ID %u out of range, max %u, ID %s\n", dev + 1, MAX_DEVS, fsm->strarg[0]);
		}
	}
	break;
	case 53:
#line 361 "p1-parser.rl"
	{ 
		unsigned int dev = fsm->arg[0] - 1;
		unsigned int valve = fsm->arg[1];
		if (dev < MAX_DEVS) {
			DEBUG("Device %u valve position: %u\n", dev + 1, valve);
			fsm->data->dev_valve[dev] = valve;
		} else {
			DEBUG("Device ID %u out of range, max %u, valve position %u\n", dev + 1, MAX_DEVS, valve);
		}
	}
	break;
	case 54:
#line 372 "p1-parser.rl"
	{ 
		unsigned int dev = fsm->arg[0] - 1;
		uint32_t timestamp = TST_to_time(fsm, 1);
		double value = (double)fsm->arg[8] / (double)fsm->arg[9];		
		if (dev < MAX_DEVS) {
			DEBUG("Device %u counter at %lu: %f %s\n", dev + 1, (unsigned long)timestamp, value, fsm->strarg[0]);
			fsm->data->dev_counter[dev] = value;
			fsm->data->dev_counter_timestamp[dev] = timestamp;
			strncpy((char *)(fsm->data->unit_dev_counter[dev]), fsm->strarg[0], LEN_UNIT + 1);
		} else {
			DEBUG("Device ID %u out of range, max %u, counter at %lu: %f %s\n", dev + 1, MAX_DEVS, (unsigned long)timestamp, value, fsm->strarg[0]);
		}
	}
	break;
	case 55:
#line 391 "p1-parser.rl"
	{ 
		
		unsigned int dev = fsm->arg[0];
		uint32_t timestamp = TST_to_time(fsm, 1);
		int status = fsm->arg[7];
		unsigned int period = fsm->arg[8];	// Recording period in minutes
		unsigned int values = fsm->arg[9];
		DEBUG("Device %u timeseries, starting time %lu, status %d, period %u, values %u:\n", dev, (unsigned long)timestamp, status, period, values);
		fsm->devcount = dev - 1;
		fsm->timeseries_time = timestamp;
		fsm->timeseries_period_minutes = period;
	}
	break;
	case 56:
#line 404 "p1-parser.rl"
	{ 
		unsigned int dev = fsm->devcount;
		DEBUG("counter values, unit %s\n", fsm->strarg[0]);
		if (dev < MAX_DEVS) {
			strncpy((char *)(fsm->data->unit_dev_counter[dev]), fsm->strarg[0], LEN_UNIT + 1);
		}
	}
	break;
	case 57:
#line 412 "p1-parser.rl"
	{ 
		unsigned int dev = fsm->devcount;
		DEBUG("cold counter values, unit %s\n", fsm->strarg[0]);
		if (dev < MAX_DEVS) {
			strncpy((char *)(fsm->data->unit_dev_counter[dev]), fsm->strarg[0], LEN_UNIT + 1);
		}
	}
	break;
	case 58:
#line 420 "p1-parser.rl"
	{ 
		
		// Note that at this point we only store a single value of the timeseries, 
		// which will end up being the most recent one...
		
		unsigned int dev = fsm->devcount;
		double value = (double)fsm->arg[0] / (double)fsm->arg[1];
		DEBUG("counter value: %f\n", value); 
		if (dev < MAX_DEVS) {
			fsm->data->dev_counter[dev] = value;
			fsm->data->dev_counter_timestamp[dev] = fsm->timeseries_time;
		}
		fsm->timeseries_time += (fsm->timeseries_period_minutes * 60);
	}
	break;
	case 59:
#line 439 "p1-parser.rl"
	{ 
		DEBUG("Gas meter ID: %s\n", fsm->strarg[0]);
		fsm->data->dev_type[0] = 3;	// Gas meter
		strncpy((char *)(fsm->data->dev_id[0]), fsm->strarg[0], LEN_EQUIPMENT_ID);
	}
	break;
	case 60:
#line 445 "p1-parser.rl"
	{ 
		unsigned int dev = 0;
		double value = (double)fsm->arg[0] / (double)fsm->arg[1];
		DEBUG("Gas meter counter: %f %s\n", value, fsm->strarg[0]); 
		fsm->data->dev_counter[dev] = value;
		fsm->data->dev_counter_timestamp[dev] = fsm->data->timestamp;
		strncpy((char *)(fsm->data->unit_dev_counter[dev]), fsm->strarg[0], LEN_UNIT + 1);
	}
	break;
	case 61:
#line 459 "p1-parser.rl"
	{DEBUG("Error while parsing\n"); fsm->parse_errors++ ; p--; { fsm->cs = 572;goto _again;} }
	break;
#line 1758 "p1-parser.c"
		}
	}

_again:
	if (  fsm->cs == 0 )
		goto _out;
	if ( ++p != pe )
		goto _resume;
	_test_eof: {}
	if ( p == eof )
	{
	const char *__acts = _parser_actions + _parser_eof_actions[ fsm->cs];
	unsigned int __nacts = (unsigned int) *__acts++;
	while ( __nacts-- > 0 ) {
		switch ( *__acts++ ) {
	case 61:
#line 459 "p1-parser.rl"
	{DEBUG("Error while parsing\n"); fsm->parse_errors++ ; p--; { fsm->cs = 572;	if ( p == pe )
		goto _test_eof;
goto _again;} }
	break;
#line 1780 "p1-parser.c"
		}
	}
	}

	_out: {}
	}

#line 638 "p1-parser.rl"
	
	fsm->pe = pe;
}

int dsmr_parser_finish(dsmr_parser_t *fsm)
{
	if ( fsm->cs == parser_error )			// Machine failed before matching
		return -1;
	if ( fsm->cs >= parser_first_final )	// Final state reached
		return 1;
	return 0;								// Final state not reached
}

